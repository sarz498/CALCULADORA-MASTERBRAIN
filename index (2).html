<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculadora MASTERBRAIN</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            margin: 0;
            color: #333;
            padding: 20px;
            box-sizing: border-box;
        }
        .calculator-container {
            display: flex;
            max-width: 1200px;
            width: 100%;
            gap: 20px;
        }
        .calculator {
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 25px;
            width: 380px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
            flex-shrink: 0;
        }
        .panel {
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        .display-container {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .display {
            text-align: right;
            font-size: 28px;
            height: 36px;
            overflow: hidden;
            margin-bottom: 5px;
        }
        .history {
            text-align: right;
            font-size: 14px;
            color: #666;
            height: 18px;
            overflow: hidden;
        }
        .tabs {
            display: flex;
            margin-bottom: 15px;
        }
        .tab {
            flex: 1;
            text-align: center;
            padding: 10px;
            background-color: #e9ecef;
            cursor: pointer;
            transition: all 0.3s;
        }
        .tab.active {
            background-color: #007bff;
            color: white;
            font-weight: bold;
        }
        .tab:first-child {
            border-radius: 5px 0 0 5px;
        }
        .tab:last-child {
            border-radius: 0 5px 5px 0;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .buttons {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
        }
        button {
            border: none;
            border-radius: 8px;
            padding: 15px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        .number {
            background-color: #f8f9fa;
            color: #333;
        }
        .operation {
            background-color: #007bff;
            color: white;
        }
        .function {
            background-color: #6c757d;
            color: white;
        }
        .advanced {
            background-color: #28a745;
            color: white;
        }
        .equals {
            background-color: #dc3545;
            color: white;
            grid-column: span 2;
        }
        .clear {
            background-color: #ffc107;
            color: #333;
        }
        .memory {
            background-color: #17a2b8;
            color: white;
        }
        .history-panel {
            flex-grow: 1;
            overflow-y: auto;
            margin-bottom: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            background-color: #f8f9fa;
        }
        .history-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
        }
        .history-item:hover {
            background-color: #e9ecef;
        }
        .history-item:last-child {
            border-bottom: none;
        }
        .nl-input {
            display: flex;
            gap: 10px;
            margin-top: auto;
        }
        .nl-input input {
            flex-grow: 1;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #ddd;
            font-size: 16px;
        }
        .nl-input button {
            padding: 12px 20px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
        .nl-result {
            margin-top: 10px;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 8px;
            min-height: 20px;
        }
        h3 {
            margin-top: 0;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="calculator-container">
        <div class="calculator">
            <div class="display-container">
                <div class="history" id="history"></div>
                <div class="display" id="display">0</div>
            </div>
            
            <div class="tabs">
                <div class="tab active" onclick="switchTab('basic')">Básica</div>
                <div class="tab" onclick="switchTab('scientific')">Científica</div>
                <div class="tab" onclick="switchTab('calculus')">Cálculo</div>
            </div>
            
            <div id="basic" class="tab-content active">
                <div class="buttons">
                    <button class="clear" onclick="clearDisplay()">C</button>
                    <button class="memory" onclick="memoryRecall()">MR</button>
                    <button class="memory" onclick="memoryClear()">MC</button>
                    <button class="memory" onclick="memoryAdd()">M+</button>
                    <button class="function" onclick="backspace()">←</button>
                    
                    <button class="number" onclick="addToDisplay('7')">7</button>
                    <button class="number" onclick="addToDisplay('8')">8</button>
                    <button class="number" onclick="addToDisplay('9')">9</button>
                    <button class="operation" onclick="addToDisplay('/')">/</button>
                    <button class="function" onclick="addToDisplay('%')">%</button>
                    
                    <button class="number" onclick="addToDisplay('4')">4</button>
                    <button class="number" onclick="addToDisplay('5')">5</button>
                    <button class="number" onclick="addToDisplay('6')">6</button>
                    <button class="operation" onclick="addToDisplay('*')">×</button>
                    <button class="function" onclick="addToDisplay('sqrt(')">√</button>
                    
                    <button class="number" onclick="addToDisplay('1')">1</button>
                    <button class="number" onclick="addToDisplay('2')">2</button>
                    <button class="number" onclick="addToDisplay('3')">3</button>
                    <button class="operation" onclick="addToDisplay('-')">-</button>
                    <button class="function" onclick="addToDisplay('^')">x^y</button>
                    
                    <button class="number" onclick="addToDisplay('0')">0</button>
                    <button class="number" onclick="addToDisplay('.')">.</button>
                    <button class="equals" onclick="calculate()">=</button>
                    <button class="operation" onclick="addToDisplay('+')">+</button>
                    <button class="function" onclick="addToDisplay('(')">(</button>
                    <button class="function" onclick="addToDisplay(')')">)</button>
                </div>
            </div>
            
            <div id="scientific" class="tab-content">
                <div class="buttons">
                    <button class="function" onclick="addToDisplay('sin(')">sin</button>
                    <button class="function" onclick="addToDisplay('cos(')">cos</button>
                    <button class="function" onclick="addToDisplay('tan(')">tan</button>
                    <button class="function" onclick="addToDisplay('asin(')">sin⁻¹</button>
                    <button class="function" onclick="addToDisplay('acos(')">cos⁻¹</button>
                    
                    <button class="function" onclick="addToDisplay('sinh(')">sinh</button>
                    <button class="function" onclick="addToDisplay('cosh(')">cosh</button>
                    <button class="function" onclick="addToDisplay('tanh(')">tanh</button>
                    <button class="function" onclick="addToDisplay('ln(')">ln</button>
                    <button class="function" onclick="addToDisplay('log(')">log</button>
                    
                    <button class="function" onclick="addToDisplay('pi')">π</button>
                    <button class="function" onclick="addToDisplay('e')">e</button>
                    <button class="function" onclick="addToDisplay('factorial(')">n!</button>
                    <button class="function" onclick="addToDisplay('abs(')">|x|</button>
                    <button class="function" onclick="addToDisplay('random()')">rand</button>
                    
                    <button class="advanced" onclick="calculateDerivative()">d/dx</button>
                    <button class="advanced" onclick="calculateIntegral()">∫dx</button>
                    <button class="advanced" onclick="calculateLimit()">lim</button>
                    <button class="advanced" onclick="addToDisplay('sum(')">∑</button>
                    <button class="advanced" onclick="addToDisplay('product(')">∏</button>
                    
                    <button class="function" onclick="addToDisplay('1/(')">1/x</button>
                    <button class="function" onclick="addToDisplay('exp(')">e^x</button>
                    <button class="function" onclick="addToDisplay('10^(')">10^x</button>
                    <button class="function" onclick="addToDisplay('2^(')">2^x</button>
                    <button class="function" onclick="addToDisplay('log2(')">log₂</button>
                </div>
            </div>
            
            <div id="calculus" class="tab-content">
                <div class="buttons">
                    <button class="advanced" onclick="calculateDerivativeAtPoint()">f'(x₀)</button>
                    <button class="advanced" onclick="calculateSecondDerivative()">f''(x)</button>
                    <button class="advanced" onclick="calculatePartialDerivative()">∂/∂x</button>
                    <button class="advanced" onclick="calculateDefiniteIntegral()">∫a→b</button>
                    <button class="advanced" onclick="calculateTaylorSeries()">Taylor</button>
                    
                    <button class="advanced" onclick="calculateGradient()">∇f</button>
                    <button class="advanced" onclick="calculateDivergence()">∇·F</button>
                    <button class="advanced" onclick="calculateCurl()">∇×F</button>
                    <button class="advanced" onclick="calculateLaplacian()">∇²</button>
                    <button class="advanced" onclick="calculateLineIntegral()">∮</button>
                    
                    <button class="advanced" onclick="solveODE()">ODE</button>
                    <button class="advanced" onclick="solvePDE()">PDE</button>
                    <button class="advanced" onclick="calculateFourierTransform()">F(ω)</button>
                    <button class="advanced" onclick="calculateLaplaceTransform()">L{f}</button>
                    <button class="advanced" onclick="calculateZTransform()">Z{f}</button>
                    
                    <button class="advanced" onclick="calculateMatrixDet()">det(A)</button>
                    <button class="advanced" onclick="calculateMatrixInv()">A⁻¹</button>
                    <button class="advanced" onclick="calculateMatrixEigen()">eig(A)</button>
                    <button class="advanced" onclick="calculateMatrixRank()">rank(A)</button>
                    <button class="advanced" onclick="solveLinearSystem()">Ax=b</button>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <div>
                <h3>Historial de Operaciones</h3>
                <div class="history-panel" id="fullHistory"></div>
            </div>
            
            <div>
                <h3>Lenguaje Natural</h3>
                <div class="nl-input">
                    <input type="text" id="nlQuery" placeholder="Escribe una operación en lenguaje natural (ej: 'sumar 5 más 3')" onkeypress="if(event.key === 'Enter') processNaturalLanguage()">
                    <button onclick="processNaturalLanguage()">Calcular</button>
                </div>
                <div class="nl-result" id="nlResult"></div>
            </div>
        </div>
    </div>

    <script>
        // Variables globales
        let currentDisplay = '0';
        let memory = 0;
        let history = [];
        let fullHistory = [];
        const display = document.getElementById('display');
        const historyDisplay = document.getElementById('history');
        const fullHistoryDisplay = document.getElementById('fullHistory');
        const nlQueryInput = document.getElementById('nlQuery');
        const nlResultDisplay = document.getElementById('nlResult');
        
        // Funciones básicas
        function updateDisplay() {
            display.textContent = currentDisplay;
        }
        
        function addToDisplay(value) {
            // Si es una función matemática, manejar diferente
            const mathFuncs = ['sin(', 'cos(', 'tan(', 'sqrt(', 'log(', 'ln(', 'exp(', 'asin(', 'acos(', 'atan(', 'sinh(', 'cosh(', 'tanh('];
            
            if (mathFuncs.some(func => value.startsWith(func))) {
                if (currentDisplay === '0') {
                    currentDisplay = value;
                } else {
                    // Verificar si el último carácter es un operador
                    const lastChar = currentDisplay.slice(-1);
                    if (/[\d\)]/.test(lastChar)) {
                        currentDisplay += '*' + value; // Multiplicación implícita
                    } else {
                        currentDisplay += value;
                    }
                }
            } else if (value === 'pi') {
                addToDisplay(Math.PI.toString());
            } else if (value === 'e') {
                addToDisplay(Math.E.toString());
            } else if (value === 'random()') {
                addToDisplay(Math.random().toString());
            } else {
                if (currentDisplay === '0' && value !== '.' && !value.endsWith('(')) {
                    currentDisplay = value;
                } else {
                    currentDisplay += value;
                }
            }
            updateDisplay();
        }
        
        function clearDisplay() {
            currentDisplay = '0';
            updateDisplay();
        }
        
        function backspace() {
            if (currentDisplay.length === 1) {
                currentDisplay = '0';
            } else {
                currentDisplay = currentDisplay.slice(0, -1);
            }
            updateDisplay();
        }
        
        // Funciones matemáticas avanzadas
        function factorial(n) {
            if (n < 0) return NaN;
            if (n === 0 || n === 1) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) {
                result *= i;
            }
            return result;
        }
        
        // Función de evaluación segura mejorada
        function evaluateExpression(expr) {
            try {
                // Preprocesar la expresión
                let processedExpr = expr
                    .replace(/\^/g, '**')
                    .replace(/sqrt\(/g, 'Math.sqrt(')
                    .replace(/(sin|cos|tan|asin|acos|atan|sinh|cosh|tanh|ln|log|log2|exp|abs)\(/g, 'Math.$1(')
                    .replace(/pi/g, 'Math.PI')
                    .replace(/e/g, 'Math.E')
                    .replace(/factorial\(/g, 'factorial(')
                    .replace(/random\(\)/g, 'Math.random()')
                    .replace(/sum\((\d+),(\d+),(.+)\)/g, (match, start, end, expr) => {
                        return `sumNumbers(${start},${end},'${expr}')`;
                    })
                    .replace(/product\((\d+),(\d+),(.+)\)/g, (match, start, end, expr) => {
                        return `productNumbers(${start},${end},'${expr}')`;
                    });

                // Balancear paréntesis automáticamente
                let openParens = (processedExpr.match(/\(/g) || []).length;
                let closeParens = (processedExpr.match(/\)/g) || []).length;
                processedExpr += ')'.repeat(openParens - closeParens);

                // Función auxiliar para sumatorias
                function sumNumbers(start, end, expr) {
                    let total = 0;
                    for (let i = start; i <= end; i++) {
                        total += evaluateExpression(expr.replace(/n/g, i));
                    }
                    return total;
                }

                // Función auxiliar para productorias
                function productNumbers(start, end, expr) {
                    let total = 1;
                    for (let i = start; i <= end; i++) {
                        total *= evaluateExpression(expr.replace(/n/g, i));
                    }
                    return total;
                }

                return Function(`"use strict"; return (${processedExpr})`)();
            } catch (error) {
                console.error("Error evaluating expression:", error);
                return NaN;
            }
        }
        
        // Funciones de cálculo implementadas completamente
        function calculateDerivative() {
            try {
                const expr = prompt("Ingrese la función f(x) para derivar (ej: x^2):", currentDisplay);
                if (!expr) return;
                
                const h = 0.0001;
                const f = new Function('x', `return ${expr.replace(/\^/g, '**')};`);
                const x = parseFloat(prompt("Ingrese el valor de x para evaluar la derivada:", "1"));
                const derivative = (f(x + h) - f(x - h)) / (2 * h);
                
                currentDisplay = derivative.toString();
                addToFullHistory(`d/dx(${expr}) at x=${x} = ${derivative}`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        function calculateDerivativeAtPoint() {
            try {
                const expr = prompt("Ingrese f(x):", currentDisplay);
                if (!expr) return;
                const x0 = parseFloat(prompt("Ingrese el punto x₀:", "0"));
                
                const h = 0.0001;
                const f = new Function('x', `return ${expr.replace(/\^/g, '**')};`);
                const derivative = (f(x0 + h) - f(x0 - h)) / (2 * h);
                
                currentDisplay = derivative.toString();
                addToFullHistory(`f'(${x0}) of ${expr} = ${derivative}`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        function calculateSecondDerivative() {
            try {
                const expr = prompt("Ingrese f(x) para segunda derivada:", currentDisplay);
                if (!expr) return;
                const x0 = parseFloat(prompt("Ingrese el punto x₀:", "0"));
                
                const h = 0.0001;
                const f = new Function('x', `return ${expr.replace(/\^/g, '**')};`);
                const secondDeriv = (f(x0 + h) - 2*f(x0) + f(x0 - h)) / (h*h);
                
                currentDisplay = secondDeriv.toString();
                addToFullHistory(`f''(${x0}) of ${expr} = ${secondDeriv}`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        function calculatePartialDerivative() {
            try {
                const expr = prompt("Ingrese f(x,y) para derivada parcial (ej: x^2*y):", currentDisplay);
                if (!expr) return;
                const variable = prompt("¿Derivar respecto a x o y?", "x");
                const x0 = parseFloat(prompt(`Valor de ${variable === 'x' ? 'x' : 'y'} para evaluar:`, "1"));
                const otherVal = parseFloat(prompt(`Valor de ${variable === 'x' ? 'y' : 'x'}:`, "1"));
                
                const h = 0.0001;
                let f, derivative;
                
                if (variable === 'x') {
                    f = new Function('x', 'y', `return ${expr.replace(/\^/g, '**')};`);
                    derivative = (f(x0 + h, otherVal) - f(x0 - h, otherVal)) / (2 * h);
                } else {
                    f = new Function('x', 'y', `return ${expr.replace(/\^/g, '**')};`);
                    derivative = (f(otherVal, x0 + h) - f(otherVal, x0 - h)) / (2 * h);
                }
                
                currentDisplay = derivative.toString();
                addToFullHistory(`∂f/∂${variable} of ${expr} at ${variable}=${x0} = ${derivative}`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        function calculateIntegral() {
            try {
                const expr = prompt("Ingrese la función f(x) para integrar:", currentDisplay);
                if (!expr) return;
                
                // Integral numérica usando la regla de Simpson
                const a = parseFloat(prompt("Límite inferior a:", "0"));
                const b = parseFloat(prompt("Límite superior b:", "1"));
                const n = 1000; // Número de subdivisiones
                
                const f = new Function('x', `return ${expr.replace(/\^/g, '**')};`);
                const h = (b - a) / n;
                let sum = f(a) + f(b);
                
                for (let i = 1; i < n; i++) {
                    const x = a + i * h;
                    sum += i % 2 === 0 ? 2 * f(x) : 4 * f(x);
                }
                
                const integral = sum * h / 3;
                currentDisplay = integral.toString();
                addToFullHistory(`∫${expr}dx from ${a} to ${b} ≈ ${integral}`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        function calculateDefiniteIntegral() {
            try {
                const expr = prompt("Ingrese la función f(x) para integrar:", currentDisplay);
                if (!expr) return;
                
                const a = parseFloat(prompt("Límite inferior a:", "0"));
                const b = parseFloat(prompt("Límite superior b:", "1"));
                const n = 1000; // Número de subdivisiones
                
                const f = new Function('x', `return ${expr.replace(/\^/g, '**')};`);
                let sum = 0;
                const dx = (b - a) / n;
                
                for (let i = 0; i < n; i++) {
                    const x = a + i * dx;
                    sum += f(x) * dx;
                }
                
                currentDisplay = sum.toString();
                addToFullHistory(`∫[${a},${b}] ${expr} dx ≈ ${sum}`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        function calculateLimit() {
            try {
                const expr = prompt("Ingrese la función f(x):", currentDisplay);
                if (!expr) return;
                const x0 = prompt("x tiende a (puede ser número o 'inf'):", "0");
                
                const f = new Function('x', `return ${expr.replace(/\^/g, '**')};`);
                let limit;
                
                if (x0 === 'inf') {
                    // Límite en infinito
                    const largeNumber = 1e10;
                    limit = f(largeNumber);
                } else {
                    // Límite en punto finito (aproximación numérica)
                    const h = 0.0001;
                    limit = (f(parseFloat(x0) + h) + f(parseFloat(x0) - h)) / 2;
                }
                
                currentDisplay = limit.toString();
                addToFullHistory(`lim(${expr}) as x→${x0} ≈ ${limit}`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        function calculateTaylorSeries() {
            try {
                const expr = prompt("Ingrese f(x) para serie de Taylor:", currentDisplay);
                if (!expr) return;
                
                const x0 = parseFloat(prompt("Punto de expansión x₀:", "0"));
                const degree = parseInt(prompt("Grado del polinomio:", "3"));
                
                const f = new Function('x', `return ${expr.replace(/\^/g, '**')};`);
                let taylorSeries = `f(${x0})`;
                let factorial = 1;
                
                // Calcular derivadas numéricamente
                for (let n = 1; n <= degree; n++) {
                    factorial *= n;
                    const h = 0.0001;
                    let nthDerivative = 0;
                    
                    // Cálculo numérico de la n-ésima derivada
                    for (let k = 0; k <= n; k++) {
                        const sign = Math.pow(-1, k);
                        const comb = factorial / (factorialize(k) * factorialize(n - k));
                        nthDerivative += sign * comb * f(x0 + (n - 2*k)*h);
                    }
                    
                    nthDerivative /= Math.pow(2*h, n);
                    const term = (nthDerivative / factorial) * Math.pow(x - x0, n);
                    
                    taylorSeries += ` + (${nthDerivative.toFixed(4)}/${factorial})(x-${x0})^${n}`;
                }
                
                currentDisplay = `Taylor: ${taylorSeries}`;
                addToFullHistory(`Taylor(${expr}) at x=${x0}: ${taylorSeries}`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        function calculateGradient() {
            try {
                const expr = prompt("Ingrese f(x,y) para calcular el gradiente (ej: x^2*y):", currentDisplay);
                if (!expr) return;
                const x = parseFloat(prompt("Valor de x:", "1"));
                const y = parseFloat(prompt("Valor de y:", "1"));
                
                const h = 0.0001;
                const f = new Function('x', 'y', `return ${expr.replace(/\^/g, '**')};`);
                
                // Derivada parcial respecto a x
                const df_dx = (f(x + h, y) - f(x - h, y)) / (2 * h);
                // Derivada parcial respecto a y
                const df_dy = (f(x, y + h) - f(x, y - h)) / (2 * h);
                
                currentDisplay = `[${df_dx.toFixed(4)}, ${df_dy.toFixed(4)}]`;
                addToFullHistory(`∇f(${expr}) at (${x},${y}) = [${df_dx.toFixed(4)}, ${df_dy.toFixed(4)}]`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        function calculateDivergence() {
            try {
                const f1 = prompt("Componente x del campo vectorial F (ej: x*y):", "x*y");
                const f2 = prompt("Componente y del campo vectorial F (ej: y^2):", "y^2");
                if (!f1 || !f2) return;
                const x = parseFloat(prompt("Valor de x:", "1"));
                const y = parseFloat(prompt("Valor de y:", "1"));
                
                const h = 0.0001;
                const Fx = new Function('x', 'y', `return ${f1.replace(/\^/g, '**')};`);
                const Fy = new Function('x', 'y', `return ${f2.replace(/\^/g, '**')};`);
                
                // dFx/dx
                const dFx_dx = (Fx(x + h, y) - Fx(x - h, y)) / (2 * h);
                // dFy/dy
                const dFy_dy = (Fy(x, y + h) - Fy(x, y - h)) / (2 * h);
                
                const divergence = dFx_dx + dFy_dy;
                currentDisplay = divergence.toString();
                addToFullHistory(`∇·F = ∂(${f1})/∂x + ∂(${f2})/∂y at (${x},${y}) = ${divergence}`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        function calculateCurl() {
            try {
                const f1 = prompt("Componente x del campo vectorial F (ej: -y):", "-y");
                const f2 = prompt("Componente y del campo vectorial F (ej: x):", "x");
                if (!f1 || !f2) return;
                const x = parseFloat(prompt("Valor de x:", "1"));
                const y = parseFloat(prompt("Valor de y:", "1"));
                
                const h = 0.0001;
                const Fx = new Function('x', 'y', `return ${f1.replace(/\^/g, '**')};`);
                const Fy = new Function('x', 'y', `return ${f2.replace(/\^/g, '**')};`);
                
                // dFy/dx
                const dFy_dx = (Fy(x + h, y) - Fy(x - h, y)) / (2 * h);
                // dFx/dy
                const dFx_dy = (Fx(x, y + h) - Fx(x, y - h)) / (2 * h);
                
                const curl = dFy_dx - dFx_dy;
                currentDisplay = curl.toString();
                addToFullHistory(`∇×F = ∂(${f2})/∂x - ∂(${f1})/∂y at (${x},${y}) = ${curl}`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        function calculateLaplacian() {
            try {
                const expr = prompt("Ingrese f(x,y) para el laplaciano (ej: x^2 + y^2):", currentDisplay);
                if (!expr) return;
                const x = parseFloat(prompt("Valor de x:", "1"));
                const y = parseFloat(prompt("Valor de y:", "1"));
                
                const h = 0.0001;
                const f = new Function('x', 'y', `return ${expr.replace(/\^/g, '**')};`);
                
                // Segundas derivadas
                const d2f_dx2 = (f(x + h, y) - 2*f(x, y) + f(x - h, y)) / (h*h);
                const d2f_dy2 = (f(x, y + h) - 2*f(x, y) + f(x, y - h)) / (h*h);
                
                const laplacian = d2f_dx2 + d2f_dy2;
                currentDisplay = laplacian.toString();
                addToFullHistory(`∇²f(${expr}) at (${x},${y}) = ${laplacian}`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        function calculateLineIntegral() {
            try {
                const f1 = prompt("Componente x del campo vectorial F (ej: -y):", "-y");
                const f2 = prompt("Componente y del campo vectorial F (ej: x):", "x");
                if (!f1 || !f2) return;
                
                alert("Esta es una implementación simplificada. La integral de línea se calculará alrededor de un círculo unitario.");
                
                const n = 1000; // Número de puntos
                let integral = 0;
                const Fx = new Function('x', 'y', `return ${f1.replace(/\^/g, '**')};`);
                const Fy = new Function('x', 'y', `return ${f2.replace(/\^/g, '**')};`);
                
                for (let i = 0; i < n; i++) {
                    const theta = 2 * Math.PI * i / n;
                    const x = Math.cos(theta);
                    const y = Math.sin(theta);
                    const dx = -Math.sin(theta) * 2 * Math.PI / n;
                    const dy = Math.cos(theta) * 2 * Math.PI / n;
                    
                    integral += Fx(x, y) * dx + Fy(x, y) * dy;
                }
                
                currentDisplay = integral.toString();
                addToFullHistory(`∮F·dr para F=[${f1},${f2}] alrededor del círculo unitario ≈ ${integral}`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        function solveODE() {
            try {
                const ode = prompt("Ingrese la ODE (ej: dy/dx = x*y):", "x*y");
                if (!ode) return;
                const x0 = parseFloat(prompt("Valor inicial x0:", "0"));
                const y0 = parseFloat(prompt("Valor inicial y0:", "1"));
                const xEnd = parseFloat(prompt("Valor final de x:", "1"));
                const steps = parseInt(prompt("Número de pasos:", "100"));
                
                const h = (xEnd - x0) / steps;
                let x = x0;
                let y = y0;
                
                const f = new Function('x', 'y', `return ${ode.replace(/\^/g, '**')};`);
                
                // Método de Euler
                for (let i = 0; i < steps; i++) {
                    y += h * f(x, y);
                    x += h;
                }
                
                currentDisplay = y.toString();
                addToFullHistory(`Solución de dy/dx=${ode} con y(${x0})=${y0} en x=${xEnd}: y ≈ ${y}`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        function solvePDE() {
            try {
                alert("Resolución de PDEs es compleja. Esta es una implementación muy simplificada para la ecuación de calor.");
                
                const length = parseFloat(prompt("Longitud de la barra:", "1"));
                const time = parseFloat(prompt("Tiempo final:", "0.1"));
                const alpha = parseFloat(prompt("Coeficiente de difusión:", "0.01"));
                const nx = parseInt(prompt("Número de puntos espaciales:", "10"));
                const nt = parseInt(prompt("Número de pasos temporales:", "100"));
                
                const dx = length / (nx - 1);
                const dt = time / nt;
                
                if (dt > dx*dx / (2*alpha)) {
                    alert("Advertencia: El esquema puede ser inestable con estos parámetros.");
                }
                
                // Condición inicial (temperatura en t=0)
                let u = new Array(nx).fill(0);
                u[Math.floor(nx/2)] = 1; // Punto caliente en el centro
                
                // Condiciones de frontera
                const leftBC = 0;
                const rightBC = 0;
                
                // Solución numérica
                for (let n = 0; n < nt; n++) {
                    let newU = [...u];
                    
                    for (let i = 1; i < nx - 1; i++) {
                        newU[i] = u[i] + alpha * dt / (dx*dx) * (u[i+1] - 2*u[i] + u[i-1]);
                    }
                    
                    // Aplicar condiciones de frontera
                    newU[0] = leftBC;
                    newU[nx-1] = rightBC;
                    
                    u = newU;
                }
                
                currentDisplay = `u(x,${time}) ≈ [${u.slice(0, 5).map(x => x.toFixed(4))}...]`;
                addToFullHistory(`Solución de ecuación de calor en t=${time}: ${currentDisplay}`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        function calculateFourierTransform() {
            try {
                const expr = prompt("Ingrese f(t) para transformada de Fourier (ej: sin(t)):", currentDisplay);
                if (!expr) return;
                const omega = parseFloat(prompt("Frecuencia angular ω:", "1"));
                const T = parseFloat(prompt("Periodo de integración T:", "10"));
                const n = 1000; // Número de puntos
                
                const f = new Function('t', `return ${expr.replace(/\^/g, '**')};`);
                let real = 0;
                let imag = 0;
                const dt = T / n;
                
                for (let i = 0; i < n; i++) {
                    const t = -T/2 + i * dt;
                    const ft = f(t);
                    real += ft * Math.cos(omega * t) * dt;
                    imag -= ft * Math.sin(omega * t) * dt;
                }
                
                currentDisplay = `(${real.toFixed(4)}) + i(${imag.toFixed(4)})`;
                addToFullHistory(`F(ω=${omega}) de ${expr} ≈ ${currentDisplay}`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        function calculateLaplaceTransform() {
            try {
                const expr = prompt("Ingrese f(t) para transformada de Laplace (ej: exp(-t)):", currentDisplay);
                if (!expr) return;
                const s = parseFloat(prompt("Parámetro s:", "1"));
                const T = parseFloat(prompt("Límite superior de integración T:", "10"));
                const n = 1000; // Número de puntos
                
                const f = new Function('t', `return ${expr.replace(/\^/g, '**')};`);
                let integral = 0;
                const dt = T / n;
                
                for (let i = 0; i < n; i++) {
                    const t = i * dt;
                    integral += f(t) * Math.exp(-s * t) * dt;
                }
                
                currentDisplay = integral.toString();
                addToFullHistory(`L{f}(s=${s}) ≈ ${integral}`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        function calculateZTransform() {
            try {
                const expr = prompt("Ingrese f[n] para transformada Z (ej: a^n):", currentDisplay);
                if (!expr) return;
                const z = parseFloat(prompt("Parámetro z (ej: 1.5):", "1.5"));
                const N = parseInt(prompt("Número de términos a sumar:", "50"));
                
                const f = new Function('n', `return ${expr.replace(/\^/g, '**')};`);
                let sum = 0;
                
                for (let n = 0; n <= N; n++) {
                    sum += f(n) * Math.pow(z, -n);
                }
                
                currentDisplay = sum.toString();
                addToFullHistory(`Z{f}(z=${z}) ≈ ${sum}`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        function calculateMatrixDet() {
            try {
                const size = parseInt(prompt("Tamaño de matriz (2 o 3):", "2"));
                if (size !== 2 && size !== 3) {
                    alert("Solo tamaños 2x2 o 3x3 soportados");
                    return;
                }
                
                let matrix = [];
                for (let i = 0; i < size; i++) {
                    const row = prompt(`Fila ${i+1} (valores separados por coma):`, "1,0").split(',').map(Number);
                    matrix.push(row);
                }
                
                let det;
                if (size === 2) {
                    det = matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
                } else {
                    det = matrix[0][0] * (matrix[1][1]*matrix[2][2] - matrix[1][2]*matrix[2][1]) -
                          matrix[0][1] * (matrix[1][0]*matrix[2][2] - matrix[1][2]*matrix[2][0]) +
                          matrix[0][2] * (matrix[1][0]*matrix[2][1] - matrix[1][1]*matrix[2][0]);
                }
                
                currentDisplay = det.toString();
                addToFullHistory(`det(${JSON.stringify(matrix)}) = ${det}`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        function calculateMatrixInv() {
            try {
                const size = parseInt(prompt("Tamaño de matriz (2 o 3):", "2"));
                if (size !== 2 && size !== 3) {
                    alert("Solo tamaños 2x2 o 3x3 soportados");
                    return;
                }
                
                let matrix = [];
                for (let i = 0; i < size; i++) {
                    const row = prompt(`Fila ${i+1} (valores separados por coma):`, "1,0").split(',').map(Number);
                    matrix.push(row);
                }
                
                let det, inv;
                if (size === 2) {
                    det = matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
                    if (det === 0) {
                        alert("Matriz no invertible (determinante = 0)");
                        return;
                    }
                    inv = [
                        [matrix[1][1]/det, -matrix[0][1]/det],
                        [-matrix[1][0]/det, matrix[0][0]/det]
                    ];
                } else {
                    det = matrix[0][0] * (matrix[1][1]*matrix[2][2] - matrix[1][2]*matrix[2][1]) -
                          matrix[0][1] * (matrix[1][0]*matrix[2][2] - matrix[1][2]*matrix[2][0]) +
                          matrix[0][2] * (matrix[1][0]*matrix[2][1] - matrix[1][1]*matrix[2][0]);
                    
                    if (det === 0) {
                        alert("Matriz no invertible (determinante = 0)");
                        return;
                    }
                    
                    // Matriz de cofactores
                    const cof = [
                        [
                            matrix[1][1]*matrix[2][2] - matrix[1][2]*matrix[2][1],
                            -(matrix[1][0]*matrix[2][2] - matrix[1][2]*matrix[2][0]),
                            matrix[1][0]*matrix[2][1] - matrix[1][1]*matrix[2][0]
                        ],
                        [
                            -(matrix[0][1]*matrix[2][2] - matrix[0][2]*matrix[2][1]),
                            matrix[0][0]*matrix[2][2] - matrix[0][2]*matrix[2][0],
                            -(matrix[0][0]*matrix[2][1] - matrix[0][1]*matrix[2][0])
                        ],
                        [
                            matrix[0][1]*matrix[1][2] - matrix[0][2]*matrix[1][1],
                            -(matrix[0][0]*matrix[1][2] - matrix[0][2]*matrix[1][0]),
                            matrix[0][0]*matrix[1][1] - matrix[0][1]*matrix[1][0]
                        ]
                    ];
                    
                    // Transpuesta de la matriz de cofactores dividida por el determinante
                    inv = [
                        [cof[0][0]/det, cof[1][0]/det, cof[2][0]/det],
                        [cof[0][1]/det, cof[1][1]/det, cof[2][1]/det],
                        [cof[0][2]/det, cof[1][2]/det, cof[2][2]/det]
                    ];
                }
                
                currentDisplay = JSON.stringify(inv);
                addToFullHistory(`inv(${JSON.stringify(matrix)}) = ${currentDisplay}`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        function calculateMatrixEigen() {
            try {
                const size = parseInt(prompt("Tamaño de matriz (2 o 3):", "2"));
                if (size !== 2 && size !== 3) {
                    alert("Solo tamaños 2x2 o 3x3 soportados");
                    return;
                }
                
                let matrix = [];
                for (let i = 0; i < size; i++) {
                    const row = prompt(`Fila ${i+1} (valores separados por coma):`, "1,0").split(',').map(Number);
                    matrix.push(row);
                }
                
                if (size === 2) {
                    // Para matriz 2x2: valores propios de [a b; c d]
                    const a = matrix[0][0], b = matrix[0][1];
                    const c = matrix[1][0], d = matrix[1][1];
                    
                    const trace = a + d;
                    const det = a*d - b*c;
                    
                    const discriminant = trace*trace - 4*det;
                    
                    if (discriminant < 0) {
                        const real = trace/2;
                        const imag = Math.sqrt(-discriminant)/2;
                        currentDisplay = `${real} ± ${imag}i`;
                    } else {
                        const lambda1 = (trace + Math.sqrt(discriminant))/2;
                        const lambda2 = (trace - Math.sqrt(discriminant))/2;
                        currentDisplay = `${lambda1}, ${lambda2}`;
                    }
                } else {
                    // Para matriz 3x3: aproximación numérica simple
                    alert("Cálculo de valores propios para 3x3 es aproximado. Se usará el método de las potencias.");
                    
                    // Vector inicial aleatorio
                    let v = [Math.random(), Math.random(), Math.random()];
                    let eigenvalue = 0;
                    
                    // Método de las potencias (solo para el valor propio dominante)
                    for (let i = 0; i < 100; i++) {
                        // Multiplicar matriz por vector
                        let Av = [
                            matrix[0][0]*v[0] + matrix[0][1]*v[1] + matrix[0][2]*v[2],
                            matrix[1][0]*v[0] + matrix[1][1]*v[1] + matrix[1][2]*v[2],
                            matrix[2][0]*v[0] + matrix[2][1]*v[1] + matrix[2][2]*v[2]
                        ];
                        
                        // Calcular norma
                        const norm = Math.sqrt(Av[0]*Av[0] + Av[1]*Av[1] + Av[2]*Av[2]);
                        
                        // Normalizar
                        Av = Av.map(x => x/norm);
                        
                        // Calcular valor propio aproximado (cociente de Rayleigh)
                        const newEigenvalue = (
                            v[0]*(matrix[0][0]*v[0] + matrix[0][1]*v[1] + matrix[0][2]*v[2]) +
                            v[1]*(matrix[1][0]*v[0] + matrix[1][1]*v[1] + matrix[1][2]*v[2]) +
                            v[2]*(matrix[2][0]*v[0] + matrix[2][1]*v[1] + matrix[2][2]*v[2])
                        );
                        
                        // Verificar convergencia
                        if (Math.abs(newEigenvalue - eigenvalue) < 1e-6) {
                            eigenvalue = newEigenvalue;
                            break;
                        }
                        
                        eigenvalue = newEigenvalue;
                        v = Av;
                    }
                    
                    currentDisplay = `Valor propio dominante ≈ ${eigenvalue.toFixed(4)}`;
                }
                
                addToFullHistory(`eig(${JSON.stringify(matrix)}) ≈ ${currentDisplay}`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        function calculateMatrixRank() {
            try {
                const rows = parseInt(prompt("Número de filas de la matriz (2 o 3):", "2"));
                const cols = parseInt(prompt("Número de columnas de la matriz (2 o 3):", "2"));
                
                if (rows > 3 || cols > 3) {
                    alert("Solo matrices hasta 3x3 soportadas");
                    return;
                }
                
                let matrix = [];
                for (let i = 0; i < rows; i++) {
                    const row = prompt(`Fila ${i+1} (valores separados por coma):`, "1,0").split(',').map(Number);
                    if (row.length !== cols) {
                        alert("Número incorrecto de columnas");
                        return;
                    }
                    matrix.push(row);
                }
                
                // Método de eliminación gaussiana simplificado
                let rank = 0;
                let simplified = JSON.parse(JSON.stringify(matrix));
                
                for (let col = 0; col < cols && rank < rows; col++) {
                    // Encontrar fila con elemento no nulo en esta columna
                    let pivotRow = -1;
                    for (let row = rank; row < rows; row++) {
                        if (Math.abs(simplified[row][col]) > 1e-10) {
                            pivotRow = row;
                            break;
                        }
                    }
                    
                    if (pivotRow === -1) continue; // Columna de ceros
                    
                    // Intercambiar filas
                    if (pivotRow !== rank) {
                        [simplified[rank], simplified[pivotRow]] = [simplified[pivotRow], simplified[rank]];
                    }
                    
                    // Eliminar elementos debajo del pivote
                    for (let row = rank + 1; row < rows; row++) {
                        const factor = simplified[row][col] / simplified[rank][col];
                        for (let c = col; c < cols; c++) {
                            simplified[row][c] -= factor * simplified[rank][c];
                        }
                    }
                    
                    rank++;
                }
                
                currentDisplay = rank.toString();
                addToFullHistory(`rank(${JSON.stringify(matrix)}) = ${rank}`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        function solveLinearSystem() {
            try {
                const size = parseInt(prompt("Tamaño del sistema (2 o 3):", "2"));
                if (size !== 2 && size !== 3) {
                    alert("Solo sistemas 2x2 o 3x3 soportados");
                    return;
                }
                
                // Leer matriz A
                let A = [];
                for (let i = 0; i < size; i++) {
                    const row = prompt(`Fila ${i+1} de A (valores separados por coma):`, "1,0").split(',').map(Number);
                    if (row.length !== size) {
                        alert("Número incorrecto de columnas");
                        return;
                    }
                    A.push(row);
                }
                
                // Leer vector b
                const b = prompt(`Vector b (${size} valores separados por coma):`, "1,0").split(',').map(Number);
                if (b.length !== size) {
                    alert("Tamaño incorrecto del vector b");
                    return;
                }
                
                // Resolver sistema
                let solution;
                if (size === 2) {
                    const det = A[0][0] * A[1][1] - A[0][1] * A[1][0];
                    if (Math.abs(det) < 1e-10) {
                        alert("Sistema singular (determinante = 0)");
                        return;
                    }
                    
                    const x = (b[0] * A[1][1] - b[1] * A[0][1]) / det;
                    const y = (A[0][0] * b[1] - A[1][0] * b[0]) / det;
                    solution = [x, y];
                } else {
                    // Regla de Cramer para 3x3
                    const detA = A[0][0] * (A[1][1]*A[2][2] - A[1][2]*A[2][1]) -
                                 A[0][1] * (A[1][0]*A[2][2] - A[1][2]*A[2][0]) +
                                 A[0][2] * (A[1][0]*A[2][1] - A[1][1]*A[2][0]);
                    
                    if (Math.abs(detA) < 1e-10) {
                        alert("Sistema singular (determinante = 0)");
                        return;
                    }
                    
                    // Matriz A1 (reemplazar primera columna con b)
                    const detA1 = b[0] * (A[1][1]*A[2][2] - A[1][2]*A[2][1]) -
                                  A[0][1] * (b[1]*A[2][2] - A[1][2]*b[2]) +
                                  A[0][2] * (b[1]*A[2][1] - A[1][1]*b[2]);
                    
                    // Matriz A2 (reemplazar segunda columna con b)
                    const detA2 = A[0][0] * (b[1]*A[2][2] - A[1][2]*b[2]) -
                                  b[0] * (A[1][0]*A[2][2] - A[1][2]*A[2][0]) +
                                  A[0][2] * (A[1][0]*b[2] - b[1]*A[2][0]);
                    
                    // Matriz A3 (reemplazar tercera columna con b)
                    const detA3 = A[0][0] * (A[1][1]*b[2] - b[1]*A[2][1]) -
                                  A[0][1] * (A[1][0]*b[2] - b[1]*A[2][0]) +
                                  b[0] * (A[1][0]*A[2][1] - A[1][1]*A[2][0]);
                    
                    const x = detA1 / detA;
                    const y = detA2 / detA;
                    const z = detA3 / detA;
                    solution = [x, y, z];
                }
                
                currentDisplay = `[${solution.map(x => x.toFixed(4)).join(', ')}]`;
                addToFullHistory(`Solución de Ax=b: x = ${currentDisplay}`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        function calculateStatistics() {
            try {
                const dataStr = prompt("Ingrese datos separados por comas:", "1,2,3,4,5");
                if (!dataStr) return;
                
                const data = dataStr.split(',').map(Number);
                const n = data.length;
                const sum = data.reduce((a, b) => a + b, 0);
                const mean = sum / n;
                
                // Varianza
                const variance = data.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / n;
                const stdDev = Math.sqrt(variance);
                
                // Mediana
                const sorted = [...data].sort((a, b) => a - b);
                const median = n % 2 === 1 ? 
                    sorted[Math.floor(n/2)] : 
                    (sorted[n/2 - 1] + sorted[n/2]) / 2;
                
                // Moda
                const freq = {};
                data.forEach(num => freq[num] = (freq[num] || 0) + 1);
                const maxFreq = Math.max(...Object.values(freq));
                const modes = Object.keys(freq).filter(num => freq[num] === maxFreq);
                
                const result = `Media: ${mean}\nMediana: ${median}\nModa: ${modes.join(', ')}\nDesv. Estándar: ${stdDev}`;
                alert(result);
                currentDisplay = mean.toString();
                addToFullHistory(`Stats of [${dataStr}]: ${result.replace(/\n/g, ', ')}`);
            } catch (error) {
                currentDisplay = 'Error';
            }
            updateDisplay();
        }
        
        // Funciones de memoria
        function memoryRecall() {
            currentDisplay = memory.toString();
            updateDisplay();
        }
        
        function memoryClear() {
            memory = 0;
        }
        
        function memoryAdd() {
            try {
                memory += evaluateExpression(currentDisplay);
            } catch (error) {
                currentDisplay = 'Error';
                updateDisplay();
            }
        }
        
        // Historial
        function addToHistory(entry) {
            history.push(entry);
            if (history.length > 3) history.shift();
            historyDisplay.textContent = history.join('; ');
        }
        
        function addToFullHistory(entry) {
            fullHistory.unshift(entry);
            if (fullHistory.length > 20) fullHistory.pop();
            updateFullHistoryDisplay();
        }
        
        function updateFullHistoryDisplay() {
            fullHistoryDisplay.innerHTML = '';
            fullHistory.forEach((item, index) => {
                const historyItem = document.createElement('div');
                historyItem.className = 'history-item';
                historyItem.textContent = item;
                historyItem.onclick = () => {
                    // Al hacer clic en un item del historial, lo copiamos al display
                    const expr = item.split('=')[0].trim();
                    currentDisplay = expr;
                    updateDisplay();
                };
                fullHistoryDisplay.appendChild(historyItem);
            });
        }
        
        // Tabs
        function switchTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.getElementById(tabId).classList.add('active');
            document.querySelector(`.tab[onclick="switchTab('${tabId}')"]`).classList.add('active');
        }
        
        // Cálculo principal
        function calculate() {
            try {
                // Guardar la expresión en el historial
                const expression = currentDisplay;
                addToHistory(expression);
                
                // Evaluar la expresión
                const result = evaluateExpression(currentDisplay);
                
                // Formatear el resultado
                if (Number.isInteger(result)) {
                    currentDisplay = result.toString();
                } else {
                    currentDisplay = parseFloat(result.toFixed(10)).toString();
                }
                
                // Agregar al historial completo
                addToFullHistory(`${expression} = ${currentDisplay}`);
            } catch (error) {
                currentDisplay = 'Error';
                console.error("Error en cálculo:", error);
            }
            updateDisplay();
        }
        
        // Procesamiento de lenguaje natural
        function processNaturalLanguage() {
            const query = nlQueryInput.value.trim();
            if (!query) return;
            
            try {
                // Procesamiento básico de lenguaje natural
                let processedQuery = query.toLowerCase();
                let result;
                
                // Reemplazar términos comunes
                processedQuery = processedQuery
                    .replace(/más/g, '+')
                    .replace(/menos/g, '-')
                    .replace(/por/g, '*')
                    .replace(/dividido por/g, '/')
                    .replace(/al cuadrado/g, '^2')
                    .replace(/al cubo/g, '^3')
                    .replace(/elevado a/g, '^')
                    .replace(/raíz cuadrada de/g, 'sqrt(')
                    .replace(/seno de/g, 'sin(')
                    .replace(/coseno de/g, 'cos(')
                    .replace(/tangente de/g, 'tan(')
                    .replace(/logaritmo de/g, 'log(')
                    .replace(/logaritmo natural de/g, 'ln(')
                    .replace(/factorial de/g, 'factorial(')
                    .replace(/valor absoluto de/g, 'abs(')
                    .replace(/\bpi\b/g, 'pi')
                    .replace(/\be\b/g, 'e');
                
                // Eliminar palabras no necesarias
                processedQuery = processedQuery
                    .replace(/calcular/g, '')
                    .replace(/cuánto es/g, '')
                    .replace(/qué es/g, '')
                    .replace(/el/g, '')
                    .replace(/la/g, '')
                    .replace(/de/g, '')
                    .replace(/por favor/g, '')
                    .replace(/\s+/g, ' ')
                    .trim();
                
                // Verificar si la consulta tiene formato de ecuación simple
                if (/^[\d+\-*\/^(). ]+$/.test(processedQuery)) {
                    // Es una expresión matemática directa
                    currentDisplay = processedQuery;
                    calculate();
                    nlResultDisplay.textContent = `Resultado: ${currentDisplay}`;
                    return;
                }
                
                // Manejar preguntas específicas
                if (processedQuery.includes('sumar') || processedQuery.includes('+')) {
                    const numbers = processedQuery.match(/\d+/g) || [];
                    if (numbers.length >= 2) {
                        result = numbers.reduce((a, b) => parseFloat(a) + parseFloat(b), 0);
                    }
                } 
                else if (processedQuery.includes('restar') || processedQuery.includes('-')) {
                    const numbers = processedQuery.match(/\d+/g) || [];
                    if (numbers.length >= 2) {
                        result = numbers.reduce((a, b) => parseFloat(a) - parseFloat(b));
                    }
                }
                else if (processedQuery.includes('multiplicar') || processedQuery.includes('*')) {
                    const numbers = processedQuery.match(/\d+/g) || [];
                    if (numbers.length >= 2) {
                        result = numbers.reduce((a, b) => parseFloat(a) * parseFloat(b), 1);
                    }
                }
                else if (processedQuery.includes('dividir') || processedQuery.includes('/')) {
                    const numbers = processedQuery.match(/\d+/g) || [];
                    if (numbers.length >= 2) {
                        result = numbers.reduce((a, b) => parseFloat(a) / parseFloat(b));
                    }
                }
                else if (processedQuery.includes('factorial')) {
                    const number = processedQuery.match(/\d+/);
                    if (number) {
                        result = factorial(parseInt(number[0]));
                    }
                }
                else if (processedQuery.includes('raíz cuadrada')) {
                    const number = processedQuery.match(/\d+/);
                    if (number) {
                        result = Math.sqrt(parseInt(number[0]));
                    }
                }
                else {
                    // Intento de evaluación directa como última opción
                    try {
                        currentDisplay = processedQuery;
                        calculate();
                        result = currentDisplay;
                    } catch {
                        result = "No pude entender la solicitud. Por favor sé más específico.";
                    }
                }
                
                if (result !== undefined) {
                    nlResultDisplay.textContent = `Resultado: ${result}`;
                    addToFullHistory(`NL: "${query}" = ${result}`);
                } else {
                    nlResultDisplay.textContent = "No pude procesar tu solicitud. Intenta con otra formulación.";
                }
            } catch (error) {
                nlResultDisplay.textContent = "Ocurrió un error al procesar tu solicitud.";
                console.error("Error en procesamiento de lenguaje natural:", error);
            }
        }
        
        // Manejar entrada por teclado
        document.addEventListener('keydown', function(event) {
            const key = event.key;
            
            if (/[0-9]/.test(key)) {
                addToDisplay(key);
            } else if (['+', '-', '*', '/', '(', ')', '.', '%'].includes(key)) {
                addToDisplay(key);
            } else if (key === 'Enter') {
                if (document.activeElement === nlQueryInput) {
                    processNaturalLanguage();
                } else {
                    calculate();
                }
            } else if (key === 'Backspace') {
                backspace();
            } else if (key === 'Escape') {
                clearDisplay();
            } else if (key === '^') {
                addToDisplay('^');
            }
        });
        
        // Inicializar el historial
        updateFullHistoryDisplay();
    </script>
</body>
</html>